#include<bits/stdc++.h>
bool dfs(int src,unordered_map<int,list<int>>&adj,unordered_map<int,bool>&vis,
         unordered_map<int,bool>&dfsvis)
{
    vis[src]=1;
    dfsvis[src]=1;
    for(auto it:adj[src])
    {
        if(!vis[it])
        {
        bool check=dfs(it,adj,vis,dfsvis);
        if(check)
            return true;
        }
        else if(dfsvis[it])
        {
             return true;
        }
    }
          dfsvis[src]=false;
  
            return false;
}
int detectCycleInDirectedGraph(int n, vector < pair < int, int >> & edges)
{
    unordered_map<int,list<int>>adj;
    for(int i=0 ; i<edges.size() ; i++)
    {
       int u=edges[i].first;
        int v=edges[i].second;
        adj[u].push_back(v);
    }
    unordered_map<int,bool>vis;
    unordered_map<int,bool>dfsvis;
    for(int i=0 ; i<n ; i++)
    {
        if(!vis[i])
        {
            bool ans=dfs(i,adj,vis,dfsvis);
        if(ans==true)
            return 1;
        }
    }
    return false;
}
time=O(N+E)
space=O(n)








USING BFS AND KANH'S ALGO-
#include<bits/stdc++.h>
int detectCycleInDirectedGraph(int v, vector < pair < int, int >> & edges)
{
    int cnt=0;
     vector<int>indegree(v);
     unordered_map<int,list<int>>adj;
    vector<bool>vis(v);
    for(int i=0 ; i<edges.size()  ; i++)
    {
         int u=edges[i].first-1;
        int v=edges[i].second-1;
        adj[u].push_back(v);
    }
    for(auto i:adj)
    {
          for(auto j:i.second)
          {
               indegree[j]++;
          }
    }
    queue<int>q;
    //0 indegree vale ko push kr do
    for(int i=0 ; i<v ; i++)
    {
        if(indegree[i]==0)
        q.push(i);
    }
    //do bfs
    while(!q.empty())
    {
         int front=q.front();
         cnt++;
        q.pop();
        //neighbour indegree update
        for(auto it:adj[front])
        {
            indegree[it]--;
            if(indegree[it]==0)
                q.push(it);
        }
    }
    if(cnt==v)
     return 0;
    else
        return 1;
}
TIME-O(N+E)
SPACE=O(N+E)

